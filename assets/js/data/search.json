[ { "title": "Web全端開發課程學習心得-入坑篇", "url": "/posts/AC-learning-tips-1/", "categories": "Web Development", "tags": "Web, 學習心得", "date": "2023-07-12 23:22:00 +0800", "snippet": "離上次更新部落格已經過了 10 個多月啦（荒廢超久）！原因是這段期間，時間大部分都拿來精進自己的程式能力（當然也會耍廢打個遊戲 😂），所以就先暫時停止更新部落格。Photo by olia danilevich on pexels前言這次分享的內容主要是關於網頁開發心得，近期報名了線上全端網頁開發課程，已學習一個多月，完成了第一個階段，順勢整理一下目前的學習心得與筆記，也練練撰寫 Blog 的文筆。報名此課程的主因不外乎就是想轉職成為軟體工程師，雖然過去已經自學大概一兩年的時間了，但大多都是想學什麼就學什麼，知識點非常地零散，寫出來的程式碼品質低落、可維護性差，畢竟非本科系背景相對缺乏軟體工程學科基礎，想踏入這領域勢必要把人家學四年（甚至更久）的東西給補上。那時剛好在 FB 上看到程式開發課程的相關資訊，是一個從入門到就業的全端網頁開發培訓機構，又在 Medium 看到一些筆者分享了課程學習相關心得文，於是好好研究了一下此課程架構與規劃，發現是一個有系統性、含金量高且社群資源豐富的學習環境，而教學也是採線上課程的方式，能更彈性地運用時間進行學習。認真評估以上幾點後，覺得是一門值得投資的課程就直接手刀報名啦！課程架構課程主要架構為前端開發實作、後端應用實務、前端專修與後端專修，目前筆者已完成了前端開發實作的部分。前端開發實作的內容主要是談 JS（JavaScript）基礎概念包括：JS 演化史、基本資料結構、語法與函式物件的使用；接著介紹如何利用 JS 進行 DOM（Document Object Model）操作與事件處理，透過 API 與 Ajax 技術與後端進行資料溝通，最後以電影清單與翻牌記憶遊戲兩個小專案將前端所學加以活用並加入 MVC 軟體架構，讓寫程式開始增添軟體工程的味道在裏頭。學習心得經過一個多月的學習後，感覺自己的技術能力又更進步了，尤其對前端 JS Event 處理與 DOM 操作更為熟悉不少。雖然以前有自己學過網頁開發，但大多都是從網路上教學文上東拼西湊寫出來的，基本觀念還很模糊，程式碼也相當凌亂。在經過系統化的學習後，對於網頁開發有更深的理解!筆者每天大概安排 2~3 小時的學習時間，跟著課程的教案學習。教案除了透過文字教學外，也有一部分的預錄的影片，課程內容可根據自己的學習狀況調整學習速度；另外還會有助教安排每週建議的學習進度與目標，以及與同學、助教每週進行一次 meeting 分享學習心得與討論。課程安排方式對於全職工作者來說真的非常友善，能夠自己自由掌控學習的時間。另外也會有來自各地的同學與你一起學習，同儕間可以互相督促、討論與分享，讓你在學習的路上不孤單！一個人也許可以走得很快，但一群人可以走得更遠，軟體開發往往是需要一群人來共同維護，故同理學習上也是。目前課程已經完成第一階段了，期許自己最後可以順利完課。總結心得分享文寫起來真的很像在寫高中作文，偏偏筆者寫作文筆很差，所以希望能夠藉由持續撰寫心得文或技術文，來增強寫作能力，同時也能彙整學習到的知識，以便忘記時可以回來複習一下。" }, { "title": "基因演算法介紹-概念篇", "url": "/posts/genetic-algorithm-introduction/", "categories": "Optimization, GA", "tags": "基因演算法, 最佳化", "date": "2022-10-27 00:15:00 +0800", "snippet": "複習一下碩論用到的最佳化搜尋演算法… 只是個人的小小經驗，僅供參考。基本介紹基因演算法(Genetic Algorithm; GA)是用來解決最佳化問題的一種演算法。顧名思義，演算過程中以數學方法模仿生物各個演化的階段，而從中迭代出最適應於當前環境的個體(解)，主要流程如下，本文將以此流程逐步說明GA的運作方式。 生成第一代初始群體，由多個隨機產生的初始解(個體)組成。 計算群體內每一個體對於環境(目標解)的適應程度(fitness)。 檢查目前群體內是否已有達到目標解的個體，若未達標則進入演算法核心階段(選擇、交換及突變)。 選擇 (Selection): 在群體中根據個體的適應度，篩選要保留下來的個體(通常保留一半數量)，其餘淘汰。 交換 (Crossover): 從保留下的個體中隨機挑選兩個做為親代，倆倆之間進行基因序列的片段交換，產生出新子代。 突變 (Mutation): 交換結束後的新群體將有機會發生突變，突變發生時，個體的基因序列將隨機改變。 完成以上三階段後，將重新評估新群體內每一個體的適應度，若仍無個體達到目標解則持續進行三階段的迭代，直到找出達標的個體。生成初始群體在進行演算法迭代前，需產生多個隨機生成的個體，基於這些初始個體迭代出最佳解。這些個體在GA中通常以二進碼(binary)的序列來表示(也可以用其他形式，如: 十進碼)，其目的是讓個體能夠在演算法中的交換與突變階段順利運行。適應度評估初始產生的第一代個體或是進行完GA迭代後產生的新個體，都需要進行適應度評估(fitness)，來確認演算法是否已經找出符合目標的最佳解。 編碼與解碼 如果最佳化問題為連續問題，例如: 求解函數最最小值，其解為十進位小數的形式，這就必須將二進碼序列解碼(decode)成十進位形式的數值；相反的，由十進位轉換至二進位則為編碼(encode)。同時，二進碼序列的形式也可以對個體進行限制，避免迭代過程中脫離最佳化所設立的拘束條件(constraint)。 例如: 可以將8bits二進碼之值以內插法表示解的限制範圍 -10.0 ~ 10.0，11111111表示為10.0; 00000000表示為-10.0，10111011透過內插法計算則可約表示為 4.6，如此只要確保GA迭代過程個體符合8bits-二進碼形式，即可限制解在-10 ~10 範圍內進行搜尋。 適應函數 適應函數(fitness function)即用來計算每一個體所屬的適應度，當個體計算得出的適應度越佳時，則代表該個體離目標解越接近。可根據目標解設定合適的適應度，使演算法具備終止條件避免無止盡的迭代運算。 例如: 求$f(x)=x^2+4x-50$ 函數之最小值(舉個簡單例子，雖然這題可以秒解XD)，可以直接把此函數作成適應函數，求解目標適應值設定為-40。若個體經解碼後帶入此適應函數之輸出值≤-40，則判定找出最佳解並停止運算。 雖然-40 並非$f(x)=x^2+4x-50$ 之最小值(-54)，但在無從得知最佳解的問題中，我們可以給予一個可接受的目標值讓演算法進行求解。此外，也有可能發生給予的目標值在問題中永遠找不出來(如在上述問題中目標值設為-60 )，這時就必須將演算法進行改良: 新增另一個停止條件，ex: 如果連續100次迭代都無法找出滿足目標解之個體，則停止迭代並回傳目前群體中最好的解。 選擇選擇(selection)是進入GA核心的首要步驟，藉由適應度篩選出可以繼續存活的個體(通常保留半數)，常見的選擇方法有: 菁英式選擇、分裂式選擇、平衡式選擇與輪盤式選擇等。 菁英式: 保留群體中適應度較佳的個體 分裂式: 同時保留適應度較佳與較差的個體，中間的部分則淘汰 平衡式: 與分裂式相反，保留中間淘汰頭尾 輪盤式: 根據適應度優劣分配被選中的機率，適應度越佳選中機率越高。好比輪盤遊戲，適應度越好代表輪盤佔比的面積越大，愈容易被指針選中。 前三個方法可直接從適應度進行篩選，輪盤式則需要再進一步換算機率，但篩選效果會比較好交換經選擇保留下來的個體將有機會被挑選為親代，進行複製後兩兩成對進行基因序列片段之交換(crossover)，進而產生出新子代。常見的交換方法有: 單點交換、雙點交換與多點(遮罩)交換。 單點交換: 在親代基因序列中，隨機選擇一位置作為切斷點，再將切下來的片段兩兩互換 雙點交換: 在親代基因序列中，隨機選擇兩個位置(不重複)作為切斷點，再將切下來的片段兩兩互換 多點(遮罩)交換: 先隨機產生與個體相同長度的二進位序列作為遮罩，在親代基因序列中，對應於遮罩位置之值為1的點位進行交換。#若不用遮罩也可以直接隨機選擇序列中數個隨機點進行互換 突變交換後無論是親代或子代有機率(≤5%)發生突變(mutation)，其主要用意是為了提高群體多樣性，避免迭代過程容易陷入局部解(local optimum)的情況。常見的突變方法: 單點突變、多點突變等 單點突變: 在個體的基因序列中隨機選擇一位置，改變其值(二進位1→0, 0→1)。 多點突變: 在個體的基因序列中隨機選擇多個位置，改變其值 選擇、交換與突變除了以上常見的方法，也可以自己針對問題的特性設計一個新方法。另外，在選擇演算法的參數時，可以透過參數組合搜尋找出效果最好的參數。常見找最佳參數組合的方法有: 窮舉法、隨機搜尋法等。小結本文透過GA的迭代流程，逐步說明了每個步驟中所執行的方法與目的。基因演算法的特性適合用來解離散的最佳化問題，如: 旅行推銷員、最佳組合與排程問題等等；藉由二進碼序列的編碼與解碼，則可進一步用來解連續數值的最佳化問題。下一篇文章就會介紹如何寫出GA的code來解決最佳化問題~本文若有任何講錯的地方再請大方地Email告知我 😀Reference Worthy N. Martin, William M. Spears, 2001, Foundations of Genetic Algorithms, Morgan Kaufmann, Inc. GA Note - 基因演算法的世界: https://ithelp.ithome.com.tw/users/20111679/ironman/2577 Wiki: https://zh.wikipedia.org/zh-tw/遗传算法" }, { "title": "影像辨識-利用OpenCV進行影像處理", "url": "/posts/python-AI-OpenCV-1/", "categories": "Python, OpenCV", "tags": "Python, OpenCV, 影像辨識", "date": "2022-09-28 00:20:00 +0800", "snippet": "最近在進行影像辨識的相關專案開發，所以記錄一下學習的過程與筆記~ 只是個人的小小經驗，僅供參考。影像辨識影像辨識是AI領域中最常被應用的一塊，如: 車牌辨識、人臉辨識與物件偵測等。 影像資料前處理 是影像辨識中最重要的一環，因訓練通常需要大量資料，且未處理過的圖片資料量大，會使一般DNN模型訓練時間過長、產生overfitting等等問題，所以在訓練前通常會經過圖片濾波、降維等處理。卷積神經網路(Convolution Neural Networks; CNN)為現今影像辨識最常使用的ML模型，在輸入前幾層神經網路將二維圖片與二維過濾矩陣進行卷積，輸出一個濾波後的圖片，一個CNN模型可能會有好幾層卷積層，目的是盡可能找圖片中重要的特徵。卷積層結束後還會有池化層(pooling layer)將圖片降維、全連接層(DNN)等組成完整的CNN，後續有機會再詳細介紹卷積神經網路的架構 。卷積層運作示意圖 Source影像處理-OpenCVOpenCV為Intel主導開發的電腦視覺處理套件，支援的語言有C++, Java, Python等等。以下就先用OpenCV(Python)來進行常見的影像處理:先用pip安裝opencv的套件pip install opencv-pythonimport opencv library 與讀取圖片imread()import cv2 as cv# 讀取圖片檔存入img，第二個參數是讀取的圖片模式img = cv.imread('hamster.jpg', cv.IMREAD_UNCHANGED)\"\"\"IMREAD_COLOR 載入型式為8-bit的RGB圖片(預設)IMREAD_UNCHANGED 除RGB外，alpha透明度也載入IMREAD_GRAYSCALE 載入型式為灰階\"\"\"cv.imread讀取到的圖片資料會存成numpy的ndarray型態，便於後續圖像處理運算type(img)# Output: numpy.ndarrayresize()函式可以重新調整影像大小# 將圖片重新調整大小--&gt;(256, 256)img = cv.resize(img, (256, 256))show出圖片視窗cv.imshow('hamster', img) # 第一個參數為視窗名稱cv.waitKey() # 等待按鍵關閉圖片循環cv.destroyWindow('hamster') # 關閉特定圖片視窗將彩色圖片轉成灰階# 可以在讀取圖片時，透過**IMREAD_GRAYSCALE** 參數轉換成灰階img = cv.imread('cvTest.jpg', cv.IMREAD_GRAYSCALE)# 或是利用cvtColor()函式與COLOR_BGR2GRAY參數進行轉換img = cv.imread('cvTest.jpg', cv.IMREAD_UNCHANGED)gray_img = cv.cvtColor(img, cv.COLOR_BGR2GRAY) 常見的圖片處理方法: 模糊化、邊緣化、膨脹、侵蝕 模糊化 (blur) 模糊化常用於去除圖片的雜訊，常見方法有: 平均模糊化、高斯模糊化。 OpenCV要實現平均模糊化可使用blur()函式 img = cv.blur(img, (5, 5)) # 第二個參數為模糊化kernel矩陣大小，越大模糊效果越好 高斯模糊化與平均模糊化差別在於kernel矩陣的權值為常態分布，使用高斯模糊可以讓影像較不容易失真，在OpenCV中引用GaussianBlur()函式 img = cv.GaussianBlur(img, (7, 7), 3) # 第二個參數也是kernal矩陣大小，大小值須為奇數 # 第三個參數為矩陣權值標準差，越大模糊加權越大，效果越好 邊緣化 (邊緣偵測 edge detection) 顧名思義就是將影像的邊緣特徵凸顯出來，引用Canny()函式 # 第二、三參數為判斷是否為邊緣的閥值 # 低於第二參數不產生邊緣，高於第三參數一定產生邊緣 # 介於兩者之間會由演算法判斷 img = cv.Canny(img, 50, 120) 在進行邊緣化前通常會先將圖片模糊化，避免將過多邊緣雜訊 img = cv.GaussianBlur(img, (7, 7), 3) img = cv.Canny(img, 50, 120) 只剩眼睛跟耳朵的輪廓了… XD 膨脹 (dilate) 膨脹可以想像成將影像較高的灰階值(較白、較亮)進行擴張，將圖片較亮的地方會變大，使用OpenCV的dilate()函式實現 # 先設定kernel，越大效果越好 kernel = np.one((3, 3), dtype=\"uint8\") img = cv.dilate(img, kernel) 倉鼠眼睛的小白點變大了~ 侵蝕 (erode) 侵蝕剛好跟膨脹相反，影像中較低的灰階值會進行擴張(被黑暗侵蝕的感覺@@)，可使用OpenCV的erode()函式實現 # 一樣需先設定kernel，越大效果越好 kernel = np.one((3, 3), dtype=\"uint8\") img = cv.erode(img, kernel) 倉鼠的眼睛變更黑了(有點可怕XD) 影像做完適當的前處理後，更能凸顯重要的特徵，增加影像辨識的成功率。後續將會再繼續說明建立影像辨識模型的方法~Reference OpenCV官方文件: https://docs.opencv.org/4.x/d2/d96/tutorial_py_table_of_contents_imgproc.html https://www.ibm.com/cloud/learn/convolutional-neural-networks https://zhuanlan.zhihu.com/p/110330329" }, { "title": "Python tkinter 做出簡單的視窗應用程式", "url": "/posts/python-tkinter-learning-1/", "categories": "Python, tkinter", "tags": "Python, 視窗應用程式", "date": "2022-09-03 14:47:00 +0800", "snippet": "與大家分享本人在Python開發上的筆記，只是個人的小小經驗，僅供參考。tkinter為Python原生的視窗應用程式套件，所以只要有Python環境即可開發，不用下載其他的library。 tkinter雖然需要透過程式碼編寫介面，但還算易於使用，適合初學者開發功能較單純的使用介面。 其他Python GUI的開發模組還有PyQt, wxPython, Kivy等等，不過筆者目前只用過tkinter所以只能先分享它的用法啦~視窗基礎設定首先將tkinter的模組引用import進來，簡寫為tkimport tkinter as tk建立一個tkinter的視窗物件，並且加入維持視窗運行的methodwin = tk.Tk()win.mainloop() # 維持視窗顯示的迴圈，沒有這行程式碼視窗無法維持顯示執行後可以叫出一個空白視窗出來呼叫視窗物件的title方法去設定視窗最上方的標題名稱win.title(\"Python tkinter\")也可以更改視窗左上的圖標，指定ico檔存放的位置win.iconbitmap(\"PythonIcon.ico\") # 同目錄下的PythonIcon.ico視窗物件的geometry方法可調整視窗大小win.geometry(\"400x300\") # 400是橫軸長度; 300是縱軸長度更改視窗的背景顏色，透過config去更改win視窗物件內的屬性win.config(bg=\"skyblue\") # 更改bg屬性，顏色可以用字典key或16進位hex code指定顯示視窗需要一個迴圈，讓執行後視窗可以持續顯示，請加入這行程式碼:win.mainloop() # 維持視窗顯示的迴圈，沒有這行程式碼視窗無法維持顯示 (須放在最後一行)上方程式碼寫完後，執行一下可以看到… 完整程式碼win = tk.Tk() win.title(\"Python tkinter\") # 賦予標題名稱win.geometry(\"400x300\") # 設定視窗大小 win.iconbitmap(\"PythonIcon.ico\") # 同目錄下的PythonIcon.icowin.config(bg=\"skyblue\") # 背景顏色win.mainloop() # 維持視窗顯示的迴圈，沒有這行程式碼視窗無法維持顯示 一個具有基本功能的視窗應用程式除了主視窗之外，至少還需要能顯示文字、按鈕觸發事件、輸入視窗等等元件，以下就來說明tkinter如何建構這些元件吧~視窗文字設定要在視窗裡放置文字，須建立一個tkinter裡的Label物件在創立Label物件時，會有幾個常見的屬性可以調整。 第一個參數為Label要放置的容器物件名稱，目前只有主視窗win。tkinter還有其他容器物件如: Frame, Canvas text為Label欲顯示的文字內容 font為字體的設定(字體樣式, 字體大小, 粗體字) bg可調整Label背景顏色label_1 = tk.Label(win, # Label要顯示的容器 text=\"Python tkinter\", # label的文字內容 font=(\"Microsoft JhengHei UI\", 20, \"bold\"), # 設定字體樣式 bg=\"skyblue\" # 背景顏色)建立好文字(Label)物件後，要指示Label須放置在win容器中的哪個位置 tkinter元件的放置位置主要有三種方法: pack, grid, place這邊先說明place的使用方式，place是透過絕對座標(x, y)來指定元件位置，用法如下:label_1.place(x=80, y=100) # 值的單位為pixel按鈕元件與觸發事件要新增按鈕在視窗上，須建立一個tkinter的Button物件，建立參數如下: 第一個參數為button要放置的容器名稱，這裡放在主視窗win text為button欲顯示的文字內容 width, height分別可以調整Button的長寬大小 command為點擊此按鈕所要觸發的事件，輸入要執行的函式名btn_1 = tk.Button(win, # Button要顯示的視窗 text=\"按鈕一\", # Button的文字內容 width=15, # Button的寬度 height=1, # Button的高度 command=btn_cmd) # 按鈕點擊事件，呼叫function名btn_1.place(x=80, y=150) # 按鈕放置位置button事件須建立一個function進行觸發，這裡簡單建立一個function名為btn_cmd，按鈕點擊後會改變按鈕的文字。def btn_cmd(): btn_1.config(text=\"你已點擊此按鈕!\") # 利用config方法更改Button物件的text屬性 tkinter的所有元件物件幾乎都有config方法，可以在物件已建立後再透過config修改物件的其他屬性。點擊按鈕前點擊後…文字輸入窗格使用者有時需要輸入一些文字與程式溝通或傳送資料，在tkinter中可以使用Entry物件或Text物件，建立文字輸入的窗格 Entry: 高度為一行文字的輸入窗格，較適合用來輸入較短的資料，如: 姓名、帳戶號碼等 Text: 可以自由定義height與width屬性，適合用來輸入較長的資料，如: 一段文字，網頁HTML等等這邊先使用Entry進行演示，建立參數如下: 基本上元件都要指定一個容器物件放置，這邊也是使用主視窗win 設定輸入的字體樣式 輸入窗格的長度entrybox_1 = tk.Entry(win, font=(\"Microsoft JhengHei UI\", 10, \"bold\"), # 設定字體樣式 width=10)entrybox_1.place(x=80, y=150)執行後，就會多出一個文字輸入窗格啦~ 綜合運用 使用者輸入一些東西到文字窗格 點擊按鈕，將文字窗格的內容顯示在使視窗的Label上 按鈕的觸發事件要進行修改，首先要先讀取entrybox_1上使用者輸入的內容，再將其內容config到label_1的text屬性。def btn_cmd():\t\tusertext = entrybox_1.get() # 利用get()方法擷取entry的內容\t\tlabel_1.config(text=usertext) 完整程式碼import tkinter as tkdef btn_cmd(): usertext = entrybox_1.get() # 利用get()方法擷取entry的內容 label_1.config(text=usertext)win = tk.Tk() win.title(\"Python tkinter\") # 賦予標題名稱win.geometry(\"400x300\") # 設定視窗大小 win.iconbitmap(\"PythonIcon.ico\") # 同目錄下的PythonIcon.icowin.config(bg=\"skyblue\") # 背景顏色# 視窗文字設定label_1 = tk.Label(win, # Label要顯示的容器 text=\"Python tkinter\", # label的文字內容 font=(\"Microsoft JhengHei UI\", 20, \"bold\"), # 設定字體樣式 bg=\"skyblue\" # 背景顏色 )label_1.place(x=80, y=100)# 按鈕觸發事件btn_1 = tk.Button(win, # Button要顯示的視窗 text=\"按鈕一\", # Button的文字內容 width=10, # Button的寬度 height=1, # Button的高度 command=btn_cmd) # 按鈕點擊事件，呼叫function名btn_1.place(x=180, y=150) # 按鈕放置位置entrybox_1 = tk.Entry(win, font=(\"Microsoft JhengHei UI\", 10, \"bold\"), # 設定字體樣式 width=10)entrybox_1.place(x=80, y=150)win.mainloop() # 維持視窗顯示的迴圈，沒有這行程式碼視窗無法維持顯示執行後…輸入完文字點擊按鈕後…以上是簡單的視窗程式開發分享，後續會再更新其他tkinter更進階的視窗元件與應用~Reference Python tkinter官方文件 https://docs.python.org/3/library/tk.html" }, { "title": "Python 基本資料處理-list複製與排序", "url": "/posts/python-data-processing-1/", "categories": "Python, data", "tags": "Python, data", "date": "2022-08-29 05:33:00 +0800", "snippet": "此系列跟大家分享本人在Python開發上，遇到一些特殊資料處理的方法，只是個人的小小經驗，僅供參考。list串列的複製問題list在Python中很常用來儲存大量資料的物件，有時候會遇到需要複製list的問題，會希望複製後的新list不會被原本的list影響。 例如: 下方程式碼執行結果，b_list記憶體位址指向a_list，所以當a_list元素改變時，b_list也會跟隨改變。 a_list = [[1,2,3], 3, 3, 1] b_list = a_list # 此行是將b_list變數指向a_list的位址 a_list[0][1] = 0 # 當a_list內元素改變時，b_list也會跟著改變 #result # a_list = [[1,0,3], 3, 3, 1] # b_list = [[1,0,3], 3, 3, 1]實際去查詢a_list, b_list的記憶體位址確實也是相同的 # id 查詢記憶體編號 id(a_list) Out[20]: 1802798924800 id(b_list) Out[21]: 1802798924800但如果a_list重新宣告新的list，則新a_list會指派到新的記憶體，b_list則繼續留在原來的記憶體。 a_list = [[1,2,3], 3, 3, 1] b_list = a_list a_list = [1, 2, 3] # 重新宣告一個list #result # a_list = [1, 2, 3] # b_list = [[1,2,3], 3, 3, 1]用id查詢後兩變數位址確實也不相同 # id 查詢記憶體編號 id(a_list) Out[25]: 1802797521024 id(b_list) Out[27]: 1802794696128 會發生上述這種情況的原因是，在Python中任何變數都是Reference Type，變數宣告是透過指標指向值的位址，使用等號 = 將”舊變數” 賦值給”新變數”就會是複製”舊變數”的位址(address)而不是”舊變數”的值(value)，這也就是為何Python是一個動態型別的程式語言。Python有提供一個安全複製方法copy，確認複製到的是值(value)而不是位址(addreass) import copy a_list = [1, 2, 3, 4] b_list = copy.copy(a) id(a_list) OUT[31]: 2340117387520 id(b_list) OUT[32]: 2340087539584 # 兩者id位址不同，確定是copy到value如果是二維以上的list或是list內部具有多層級物件，則複製必須使用deepcopy import copy a_list = [[2,3],[1,4]] b_list = copy.deepcopy(a_list) # copy.copy淺複製只能處理一維的list複製，copy.deepcopy深複製則可以處理二維以上的list複製list特殊排序若有兩個陣列分別為a_list, b_list，a_list做大小排序，a_list內元素對應b_list的元素也要跟隨著排列，有幾種方法可以實現… 第一種方法 可以將a_list排序的index紀錄下來，再套用在b_list。 EX: a_list = [3,1,4,6,2,1]b_list = [4,5,2,1,2,3] a 做 小→大 排序 #sort(a)index_list = sorted(range(len(a)), key = lambda k: a[k])\"\"\"說明: range(len(a)) = [0, 1, 2, 3, 4, 5]內元素依依帶入lambda，迭代出a排列小至大的key list 再利用key list排序range(len(a))存入index_list\"\"\"# OUT: a = [1,1,2,3,4,6]index_list = [1,5,4,0,2,3] index_list為a_list排序紀錄下來的index變動位置，b_list可以依照index_list進行排列 temp = []for i in index_list: temp.append(b[i])b = copy(temp) 第二種方法 先利用zip將a_list與b_list鏈起來 zip_list = list(zip(a, b))# OUT: [(3, 4), (1, 5), (4, 2), (6, 1), (2, 2), (1, 3)] 再透過sorted排序zip_list的子串列zip_list[0] arr_zip_list = sorted(zip_list, key=lambda z: zip_list[0])# OUT: [(1, 5), (1, 3), (2, 2), (3, 4), (4, 2), (6, 1)] 最後再解zip unzip_list = list(zip(*arr_zip_list))# OUT: [(1, 1, 2, 3, 4, 6), (5, 3, 2, 4, 2, 1)]unzip_list[1] # 即為跟著a_list排序完成的b_list list元素交換若有a, b兩陣列，可直接透過程式碼第4行的方法進行交換，不需藉由第三變數暫存，但numpy.array無法支援此方法。 a = [[1,1],[2,2]] b = [[3,3],[4,4]] a[0], b[0] = b[0], a[0] # a = [[3, 3], [2, 2]] # b = [[1, 1], [4, 4]]以上為筆者過去利用Python進行資料分析時，處理list資料可能會遇到的一些坑，在此分享處理方法，僅供參考~Reference Pythonic 實踐：實用的 python 慣用法整 https://mropengate.blogspot.com/2020/07/pythonic-python.html Python - 淺複製(shallow copy)與深複製(deep copy) https://ithelp.ithome.com.tw/articles/10221255" } ]
